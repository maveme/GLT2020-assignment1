modeltype CCL uses 'http://glt.tue.nl/ccl';
modeltype GRAPH uses 'http://glt.tue.nl/graph';


transformation NewTransformation(in ccl : CCL, out GRAPH);

main() {
	ccl.rootObjects()[CCL::CloudResources]->map ccl2graph();
}

mapping CCL::CloudResources::ccl2graph() : GRAPH::Graph {
    nodes := self.resources -> map resource2boxNode();
    var machineImages := getMachineImages();
    machineImages -> forEach(machineImage){
        nodes += machineImage -> map machineImage2boxNode();
        nodes += machineImage.region.map region2boxNode();
        nodes += machineImage.memory.toString().map memory2Node();
	};
	var computingImages := getComputingImage();
    computingImages -> forEach(computingImage){
    	nodes += computingImage.label.map TypeComputing2boxNode();
        nodes += computingImage.os.toString().map os2Node();
        nodes += computingImage.vcpu.toString().map vcpu2Node();
    };
    var storageImages := getStorageImage();
    storageImages -> forEach(storageImage){
    	nodes += storageImage.label.map TypeStorage2boxNode();
        nodes += storageImage.dbEngine.toString().map dbEngine2Node();
    }
    
    

}

/*
For each cloud resource (containing a collection of machine images), a box node shall be
created labeled with the cloud resource label. There shall be outgoing solid edges from this
node to the nodes created from the machine images contained in the cloud resource
*/
mapping CCL::Resource::resource2boxNode() : GRAPH::Node {
	shape := GRAPH::Shape::BOX;
	label := self.label;
	var machineImages := self.machineImages -> map machineImage2boxNode();
	//make edges from the resource to all the machine images
	machineImages -> forEach(machineImage){
		var toAddEdge := object GRAPH::Edge{style := GRAPH::Style::SOLID; target:= machineImage};
		outEdges += toAddEdge;
	}
	
}

/*
For each region in the source model, a node in the result graph shall be created with label
the name of the region. Recall that each machine image is associated to one region. Region
nodes have box shape

Each region node is connected to two other nodes (box-shaped): one labeled ‘Storage’ and
one labeled ‘Computing’. The edges from a region node to these nodes are of solid style.
These two nodes will further be connected to nodes that represent machine images of the
given kind located in the region

*/

/*
For each machine image in the source model, a box node is created labeled with the
machine image label. There is solid edge from the node that indicates the kind of the image
to the node created from the image (see the previous bullet item)
*/

mapping CCL::MachineImage::machineImage2boxNode() : GRAPH::Node
disjuncts CCL::StorageImage::storageattr2nodes, CCL::ComputingImage::computingattr2nodes{
}

	

/*
For each node created from a storage image, there exist dashed outgoing edges to oval
nodes that show (as labels) the type of the database engine and the size of the storage
*/
mapping CCL::StorageImage::storageattr2nodes() : GRAPH::Node {
	label := self.label.toString();
	shape := GRAPH::Shape::BOX;
	
	var typeNode := self.label.map TypeStorage2boxNode();
	
//	//Construct a type of note which will display "Storage"
//	var typeOfNode = object GRAPH::Node{label := "Storage"; shape:= GRAPH::Shape::BOX };
//	
//	//Construct an edge from the type of node to this node
//	var typeEdge = object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= result};
//	typeOfNode.outEdges += typeEdge;
	
	var dbEngineNode = self.dbEngine.toString().map dbEngine2Node();
	var dbEngineEdge = object GRAPH::Edge{style := GRAPH::Style::DASHED; target:= dbEngineNode;};
	outEdges += dbEngineEdge;
	
	var memoryNode = self.memory.toString().map memory2Node();
	//var memoryNode = object GRAPH::Node{label := self.memory.toString() + " GB"; shape:= GRAPH::Shape::OVAL };
	var memoryEdge = object GRAPH::Edge{style := GRAPH::Style::DASHED; target:= memoryNode;};
	outEdges += memoryEdge;
	
	var region := self.region.map region2boxNode();
	addEdgeToRegion(region, typeNode);
	
}



/*
For each node created from a computing image, there exist dashed outgoing edges to oval
nodes that show (as labels) the operating system of the image, the number of processor
cores, and the memory size
*/
mapping CCL::ComputingImage::computingattr2nodes() : GRAPH::Node {
	label := self.label.toString();
	shape := GRAPH::Shape::BOX;
	//object GRAPH::Node{label := "Computing"; shape:= GRAPH::Shape::BOX };
	//var typeEdge = object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= result};
	
	var typeNode := self.label.map TypeComputing2boxNode();
	//var typeNode := self.label.oclAsType(self.label).map TypeComputing2boxNode();
	
	//Construct an edge from the type of node to this node
	
	//typeOfNode += typeEdge;
	
	var cpuNode = self.vcpu.toString().map vcpu2Node();
	//var cpuNode := object GRAPH::Node{label := self.vcpu.toString(); shape:= GRAPH::Shape::OVAL};
	var cpuEdge := object GRAPH::Edge{style := GRAPH::Style::DASHED; target:= cpuNode;};
	outEdges += cpuEdge;
	
	var osNode = self.os.toString().map os2Node();
	//var osNode := object GRAPH::Node{label := self.os.toString() + " cores"; shape:= GRAPH::Shape::OVAL };
	var osEdge := object GRAPH::Edge{style := GRAPH::Style::DASHED; target:= osNode;};
	outEdges += osEdge;
	
	var memoryNode = self.memory.toString().map memory2Node();
	//var memoryNode = object GRAPH::Node{label := self.memory.toString() + " GB"; shape:= GRAPH::Shape::OVAL };
	var memoryEdge = object GRAPH::Edge{style := GRAPH::Style::DASHED; target:= memoryNode;};
	outEdges += memoryEdge;
	
	
	var region := self.region.map region2boxNode();
	addEdgeToRegion(region, typeNode);
	
}

mapping String::TypeComputing2boxNode(): GRAPH::Node{
	label := "COMPUTING";
	shape := GRAPH::Shape::BOX;
	var machineLabel = self.getNodefromLabel();
	var typeEdge := object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= machineLabel};
	outEdges += typeEdge;
}

mapping String::TypeStorage2boxNode(): GRAPH::Node{
	label := "STORAGE";
	shape := GRAPH::Shape::BOX;
	var machineLabel = self.getNodefromLabel();
	var typeEdge := object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= machineLabel};
	outEdges += typeEdge;
}

mapping String::dbEngine2Node(): GRAPH::Node{
	label := self; 
	shape := GRAPH::Shape::OVAL 
}

mapping String::vcpu2Node() : GRAPH::Node {
	label := self + " cores"; 
	shape := GRAPH::Shape::OVAL 
}

mapping String::memory2Node() : GRAPH::Node {
	label := self  + " GB"; 
	shape := GRAPH::Shape::OVAL 
}

mapping CCL::MachineImage::storageSize2Node() : GRAPH::Node {
	
}

mapping CCL::MachineImage::storageType2Node() : GRAPH::Node {
	
}

mapping String::os2Node() : GRAPH::Node {
	label := self; 
	shape := GRAPH::Shape::OVAL;
}

mapping CCL::Region::region2boxNode() : GRAPH::Node {
	label := self.toString();
	shape := GRAPH::Shape::BOX;
//	var targetNode := self.label.map TypeComputing2boxNode();
//	var Edge := object GRAPH::Edge{style := GRAPH::Style::SOLID; target:= targetNode};
//	outEdges += Edge;
}

//#######################################
// HELPERS
//#######################################

helper addEdgeToRegion(inout region: GRAPH::Node, in type: GRAPH::Node){
	var newEdge := object GRAPH::Edge{style := GRAPH::Style::SOLID; target:= type};
	region.outEdges += newEdge;
}



//#######################################
// QUERIES
//#######################################



query getResources() : Sequence(CCL::Resource) {
	return CCL::Resource.allInstances()->asSequence()
}

//query String::getStorageComputingNodeFromRegion(): GRAPH::Node {
//		var machineImageNodes = getMachineImageNodeFromRegion();
//}
//
//query String::getMachineImageNodeFromRegion(): CCL::StorageImage {
//	var MIs = getStorageImage();
//	MIs -> forEach(MI){
//		if(MI.r = self){
//			return node;
//		}
//	};
//	return null;
//}

query String::getNodefromLabel(): GRAPH::Node {
	var nodes = getNodes();
	nodes -> forEach(node){
		if(node.label = self){
			return node;
		}
	};
	return null;
}

query getMachineImages() : Sequence(CCL::MachineImage) {
	return CCL::MachineImage.allInstances()->asSequence()
}

query getNodes(): Sequence(GRAPH::Node){
	return GRAPH::Node.allInstances()->asSequence();
}

query getComputingImage() : Sequence(CCL::ComputingImage) {
	return CCL::ComputingImage.allInstances()->asSequence()
}

query getStorageImage() : Sequence(CCL::StorageImage) {
	return CCL::StorageImage.allInstances()->asSequence()
}