modeltype CCL uses 'http://glt.tue.nl/ccl';
modeltype GRAPH uses 'http://glt.tue.nl/graph';


transformation NewTransformation(in ccl : CCL, out GRAPH);

main() {
	ccl.rootObjects()[CCL::CloudResources]->map ccl2graph();
}

mapping CCL::CloudResources::ccl2graph() : GRAPH::Graph {
	nodes := self.resources -> map resource2boxNode();
}

/*
For each cloud resource (containing a collection of machine images), a box node shall be
created labeled with the cloud resource label. There shall be outgoing solid edges from this
node to the nodes created from the machine images contained in the cloud resource
*/
mapping CCL::Resource::resource2boxNode() : GRAPH::Node {
	shape := GRAPH::Shape::BOX;
	label := self.label;
	var machineImages := self.machineImages -> map machineImage2boxNode();
	//make edges from the resource to all the machine images
	machineImages -> forEach(machineImage){
		var toAddEdge := object GRAPH::Edge{style := GRAPH::Style::SOLID; target:= machineImage};
		outEdges += toAddEdge;
	}
	
}

/*
For each region in the source model, a node in the result graph shall be created with label
the name of the region. Recall that each machine image is associated to one region. Region
nodes have box shape

Each region node is connected to two other nodes (box-shaped): one labeled ‘Storage’ and
one labeled ‘Computing’. The edges from a region node to these nodes are of solid style.
These two nodes will further be connected to nodes that represent machine images of the
given kind located in the region

*/

/*
For each machine image in the source model, a box node is created labeled with the
machine image label. There is solid edge from the node that indicates the kind of the image
to the node created from the image (see the previous bullet item)
*/

mapping CCL::MachineImage::machineImage2boxNode() : GRAPH::Node
disjuncts CCL::StorageImage::storageattr2nodes, CCL::ComputingImage::computingattr2nodes{
}

	

/*
For each node created from a storage image, there exist dashed outgoing edges to oval
nodes that show (as labels) the type of the database engine and the size of the storage
*/
mapping CCL::StorageImage::storageattr2nodes() : GRAPH::Node {
	label := self.label.toString();
	shape := GRAPH::Shape::BOX;
	
	//Construct a type of note which will display "Storage"
	var typeOfNode = object GRAPH::Node{label := "Storage"; shape:= GRAPH::Shape::BOX };
	
	//Construct an edge from the type of node to this node
	var typeEdge = object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= result};
	typeOfNode.outEdges += typeEdge;
	
	var dbEngineNode = object GRAPH::Node{label := self.dbEngine.toString(); shape:= GRAPH::Shape::OVAL };
	var dbEngineEdge = object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= dbEngineNode;};
	outEdges += dbEngineEdge;
	
	var memoryNode = object GRAPH::Node{label := self.memory.toString() + " GB"; shape:= GRAPH::Shape::OVAL };
	var memoryEdge = object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= memoryNode;};
	outEdges += memoryEdge;
	
	
	self.region -> map region2boxNode();
}

/*
For each node created from a computing image, there exist dashed outgoing edges to oval
nodes that show (as labels) the operating system of the image, the number of processor
cores, and the memory size
*/
mapping CCL::ComputingImage::computingattr2nodes() : GRAPH::Node {
	label := self.label.toString();
	shape := GRAPH::Shape::BOX;
	//object GRAPH::Node{label := "Computing"; shape:= GRAPH::Shape::BOX };
	//var typeEdge = object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= result};
	
	var typeOfNode := self.label -> map Type2boxNode();
	
	//Construct an edge from the type of node to this node
	
	//typeOfNode += typeEdge;
	
	var cpuNode := object GRAPH::Node{label := self.vcpu.toString(); shape:= GRAPH::Shape::OVAL};
	var cpuEdge := object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= cpuNode;};
	outEdges += cpuEdge;
	
	var osNode := object GRAPH::Node{label := self.os.toString() + " cores"; shape:= GRAPH::Shape::OVAL };
	var osEdge := object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= osNode;};
	outEdges += osEdge;
	
	var memoryNode = object GRAPH::Node{label := self.memory.toString() + " GB"; shape:= GRAPH::Shape::OVAL };
	var memoryEdge = object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= memoryNode;};
	outEdges += memoryEdge;
	
	
	
	self.region -> map region2boxNode();
}

mapping String::Type2boxNode(): GRAPH::Node{
	label := "COMPUTING";
	shape := GRAPH::Shape::BOX;
	var machineLabel = self.getMachineImageFromLabel();
	var typeEdge := object GRAPH::Edge{style := GRAPH::Style::DOTTED; target:= machineLabel};
	outEdges += typeEdge;
}

mapping CCL::MachineImage::vcpu2Node() : GRAPH::Node {

}

mapping CCL::MachineImage::memory2Node() : GRAPH::Node {
	
}

mapping CCL::MachineImage::storageSize2Node() : GRAPH::Node {
	
}

mapping CCL::MachineImage::storageType2Node() : GRAPH::Node {
	
}

mapping CCL::ComputingImage::os2Node() : GRAPH::Node {
	
}

mapping CCL::Region::region2boxNode() : GRAPH::Node {
	label := "I AM A REGION";
	shape := GRAPH::Shape::BOX;
//	outEdges := 
}

mapping CCL::StorageImage::vcpu2boxNode() : GRAPH::Node {
	label := self.toString(); 
	shape := GRAPH::Shape::OVAL
}




//#######################################
// QUERIES
//#######################################



query getResources() : Sequence(CCL::Resource) {
	return CCL::Resource.allInstances()->asSequence()
}

query String::getMachineImageFromLabel(): GRAPH::Node {
	var machineImageNodes = getNodes();
	machineImageNodes -> forEach(machineImageNode){
		if(machineImageNode.label = self){
			return machineImageNode;
		}
	};
	return null;
}

query getMachineImages() : Sequence(CCL::MachineImage) {
	return CCL::MachineImage.allInstances()->asSequence()
}

query getNodes(): Sequence(GRAPH::Node){
	return GRAPH::Node.allInstances()->asSequence();
}

query getComputingImage() : Sequence(CCL::ComputingImage) {
	return CCL::ComputingImage.allInstances()->asSequence()
}

query getStorageImage() : Sequence(CCL::StorageImage) {
	return CCL::StorageImage.allInstances()->asSequence()
}